# -------------------------------------------------------------------------------------------------
# Поговорим об основых функциях высшего порядка:
# lambda, filter, map, zip, enumerate, list comprehension

# -------------------------------------------------------------------------------------------------

#list comprehension - используется как быстрый генератор списков в одну строчку
# a = [int(input()) for i in range()] 
# сначала пишется то, чем будет заполняться список  - непосредственно сам элемент. М.б. функцией.
# потом чаще всего запускается цикл. Он может работать как по некому диапазону, так и по другому циклу.

# a = [i for i in range(1, 9)] # этот список заполнится девятью эл-ти от 1 до 9
# print(a)

# # расшифровка такая:
# a = []
# for i in range(1, 9):
#     a.append(i)
# print(a)

# # можем добавлять разные условия внутрь цикла:
# a = []
# for i in range(1, 9):
#     if i % 2 == 0:
#         a.append(i)
# print(a)

# # коваленция этой конструкция в сокращенном виде такая (добавляем условие после цикла):
# a = [i for i in range(1, 9) if i % 2 == 0]
# print(a)


# -------------------------------------------------------------------------------------------------

# zip - позволяет объединить совершенно разные последовательности в одну

# a = [1,2,3,4,5]
# b = "qwerty"
# c = {(1,2):{3,4},(5,6):{7,8},(9,10):{11,12}}

# #print(list(zip(a,b,c)))

# for i,v,c in zip(a,b,c):
#     print(i,v,c)
# # тут мы объединили последовательности в кортежи по соответствующим элементам


# -------------------------------------------------------------------------------------------------

# enumerate - каждому эл-ту последоавтельности присваивает номер, начиная с нуля. Это НЕ индексы, именно нумарация

# a = "qwertyuiop"
# for i in enumerate(a):
#     print(i)

# формируем те же кортежи, но приавляем номер кадому элементу, начиная с нуля.


# -------------------------------------------------------------------------------------------------

# lambda - это анонимная функция

# Обычно функция определяется так:
# def summ(a,b):
#     return a+b
# print(summ(5,7))

# # Но, если нам нужно использовать ф-цию всего 1 раз, то проще использовать лямбда-функцию:
# x = lambda a,b: a+b
# print(x(3,6))

# # можем добавить условия:
# x = lambda a,b: a+b if a%2==0 else 0
# print(x(2,4))


# -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  

# Рассмотрим наиболее популярные варианты применения и использования лямбда-функции:
# Начнем с map - позволяет применить ф-цию к каждому эл-ту итерируемой последовательности 
# (списки, строки, кортежи, словари и т.д.) Т.е. то, по чему можно пройтись циклом 
# и к каждому эл-ту этой послед-ти применить функцию.

# Пример - есть список, нужно каждый эл-т возвести в квадрат

# a = [1,2,3,4,5]
# def kv(x): # должен быть 1 (ОДИН) аргумент в ф-ции, т.к. этим аргументом будет эл-т последовательности
#     return x*x
# print(list(map(kv,a)))

# # так будет выглядеть решение через лямбду:
# a = [1, 2, 3, 4, 5]
# print(list(map(lambda x: x * x, a)))

# Но чаще всего с помощью map, например, переводят значения из str в int.
# Когда вводятся числа с клавиатуры, чтобы не заморачиваться с циклами.

# a = input().split()
# # вводим данные в строку через пробел; далее сплитим, получая список
# print(a)
# print(list(map(int, a)))

# но вообще сразу эту запись можно сократить:
# a = list(map(int, input().split()))
# print(a)

# -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  

# Далее рассмотрим функцию filter

a = [1,2,3,4,5]
print(list(filter(lambda x: x ** 2 if x%2==0 else False, a)))

# как работает эта ф-ция фильтр: если true, то значение счтается и выводится, если нет, то убирается из вывода.
# В пайтоне ноль - это эквивалент False, поэтому его и запиисываем в else
# Поэтому можно записать еще короче это же:
print(list(filter(lambda x: not x%2, a)))


# -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  


